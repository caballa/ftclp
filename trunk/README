===============================================================
  Failure Tabled Constraint Logic Programming by Interpolation
===============================================================

Authors: G. Gange, J.A. Navas, P. Schachte, H. Sondergaard, and
         P.J. Stuckey 
         (C)2013 The University of Melbourne.

-------------
Requirements
-------------

If your OS is linux 64 bits, then just need to install the 32-bit
libraries:

  for Ubuntu: sudo apt-get install lib32stdc++6 lib32gmp-dev lib32z1-dev 
  
  Sometimes you need to add manually the symbolic link:
        ln -s /usr/lib32/libstdc++.so.6 /usr/lib32/libstdc++.so

* Ciao

  Download Ciao from http://ciao-lang.org/download_stable.html
  The code is only tested with version CiaoDE 1.14.2 (released on
  2011-08-15 11:13:23 +0100). To avoid problems, use this version.

* Mathsat

  Download MathSAT from http://mathsat.fbk.eu/download.html
  Download only 32-bit versions.

-------------
Installation
-------------

The code is split into two components: the frontend and the
interpreter.

* The frontend is at the directory frontend. 

  1) Type:

  % cd frontend

  % make 

  % cd ..

* The interpreter is at the src directory. 

  2) CHANGE PATHS in src/Makefile.conf

  3) Type:

  % cd src

  % make 

--------
 Usage 
--------

Go first to directory frontend.

To translate CLP program to our intermediate representation:

% frontend -f ../tests/filename.pl 

Go then to directory src. To see all options, run:

% ftclp -help 

----------------
 Usage Example 
----------------

% cd frontend

% frontend -f ../tests/reach.pl > reach__tr.txt

% cd ../src

% ftclp -goal 'entry_goal(C)' -f ../frontend/reach__tr.txt

==============================================================================

--------------------------
Program instrumentation
--------------------------

The counter instrumentation for recursive clauses must be done
manually. That is, if the user wants to run with option
-infinite-pruning then

given the following program:

?- { X .=. 1}, foo(X).
foo(X):- {X1 .=. X + 1}, foo(X1).
foo(X):- {X .>. 0}.

he/she must write instead the following CLP program:

?- { X .=. 1}, foo(X,_K).
foo(X,K):- {X1 .=. X + 1, K1 .=. K - 1}, foo(X1,K1).
foo(X,_):- {X .>. 0}.

WARNING: Fail to do manually the transformation and running with
-infinite-pruning it will leave the interpreter in an undefined
behavior.

-----------------------
Program annotation
-----------------------

The input programs can be annotated with the following directives:

:- tabled(foo(_,num)).

Tells our interpreter that we should do tabling of foo/2. Moreover, it
tells us that the 2nd argument is a number and hence, we will model it
using the theory of (integer or real) linear arithmetic. The '_'
symbols tells us that the argument should be modeled with Herbrand
logic and use Prolog unification on it.

:- discriminants(bar(d,nd)).

This is optional but it may help significantly tabling.  This idea
comes from the paper Christiansen [1] that present a technique to
identify non-discriminating arguments, i.e., arguments that do not
have any impact on the control flow of the logic program. The symbol
'd' says to our interpreter that the argument is discriminant and 'nd'
non-discriminating.

[1] presents an automatic program transformation to eliminate from the
original program all the non-discriminating arguments. In the future,
we would like to use this transformation. Meanwhile, user must say so.

:- no_cache(foo(_,_)).

It says to our interpreter not to generate interpolants for foo/2 and
do not perform entailment tests to run executions of foo/2. It's a bit
redundant because if we do not annotate with :- tabled(foo(_,_)). we
can get the same behavior.


Bibliography

[1] Non-discriminating Arguments and Their Uses. H. Christiansen and
    J. P. Gallagher. ICLP'09.



