=Install And Usage=

This guide is only for Linux OS and it has only been tested with Ubuntu 12.04 on a 64-bit machine.

==Requirements==

  If your OS is linux 64 bits, then you need to install the 32-bit libraries:

  For Ubuntu:
       sudo apt-get install ia32-libs libc6-i386 libc6-dev-i386 lib32gcc1 
       lib32stdc++6 g++-4.6-multilib lib32bz2-dev  lib32z1-dev

  Also, you might need to add manually the symbolic link:
       ln -s /usr/lib32/libstdc++.so.6 /usr/lib32/libstdc++.so



==Setup==

The distribution comes as a compressed tarball named
ftclp.xx.yy.tar.gz, where xx.yy is a version number. Unpack the
distribution somewhere in your home directory and set the value of the
environment variable FTCLP_INSTALL to the absolute path of the
distribution. For example, if you've unpacked the distribution in the
directory /home/jorge/ftclp.xx.yy, then you shall add the
following commands to your profile:

{{{
export FTCLP_INSTALL=/home/jorge/ftclp.xx.yy
}}}

You might also want to update your PATH variable as follows:

{{{
export PATH=${PATH}:${FTCLP_INSTALL}/bin
}}}

{{{
make install
}}}

This will install any required third-party system.

{{{
make all
}}}

This will compile all the files and will generate the executable file
ftclp.xx.yy in the bin directory.

==Usage==

{{{
ftclp.xx.yy -help

Failure Tabled Constraint Logic Programming by Interpolation (FTCLP)
  Authors: G. Gange, J.A. Navas, P. Schachte, H. Sondergaard, and P.J. Stuckey.
  (C)2013 The University of Melbourne.
  Description: A solver for recursive Constrained Horn Clauses.

  Usage: cmmd -goal <g> -f  <input_file>.pl [options] 

         g must be a single atom between quotes (e.g., 'foo(X)') 
         For a goal with multiple atoms g1,...,gn create a new clause of the form:
         newg :- g1,...,gn. and call with -goal 'newg'

  Options: 
   -help, --help      : display this list of options
   -debug             : debug mode
   -dot-output        : display derivation tree in dot format
   -show-answers      : show answers
   -dump-interpolants : write interpolants into <input_file>.intp
   -depth     <n>     : explore up to depth n  (default unlimited)
   -solutions <n>     : compute n solutions    (default all solutions)
   -integer-arithmetic: interpret all constraints over integer arithmetic (default reals)
   -clause-pruning    : pruning at the level of clause (default no pruning)
   -pred-pruning      : pruning at the level of predicate (default no pruning)
   -infinite-pruning  : pruning infinite derivations (default no pruning)
	-min-unroll <n>: minimum number of unrollings for recursive clauses 
                          before attempting child-parent subsumption (default 1)
	-max-unroll <n>: maximum number of unrollings for recursive clauses (default unlimited)
   -minimize-intp-calls: optimization to minimize the number of interpolation calls
                         (only if interpolants are inductive)
   -unscoped-intp      : generation of not necessarily well scoped interpolants
   -scoped-intp        : generation of well scoped interpolants
}}}

===Common Usage Configurations===

  # Standard CLP without tabling: run without options
  # Failure-Tabling CLP: run with options *-clause-pruning* *-unscoped-intp*
  # Failure-Tabling CLP with special treatment for infinite derivations: run with options *-clause-pruning* *-scoped-intp* *-infinite-pruning*

===Scoped vs Unscoped interpolants===

An interpolant is _well scoped_ with respect to a head clause H (or a predicate P) if only contains variables of H (P). Otherwise, we say it is an _unscoped_ or _out-of-scoped_ interpolant. Ideally, we would like to have scoped interpolants because they can prune more derivations but they are currently more expensive to compute. 

The option *-scoped-intp* ensures that only scoped interpolants are computed. The other option *-unscoped-intp* may produce unscoped interpolants which may reduce the pruning capabilities although it's generally faster.
  
===View Answers (Solutions) ===

To see the answers (solutions) generated by the CLP program use the option -show-answers. Currently, the format of the answers is very limited. Current CLP systems dump the state of the solver and projected onto a set of variables of interest. Instead, we simply print the sequence of executed clauses that led to a solution. A clause is denoted by p/n/k where p is the name of the predicate functor, n is the arity of the predicate, and k is the number of the clause. The number of the clauses are assigned based on the order the clauses appear in the program.