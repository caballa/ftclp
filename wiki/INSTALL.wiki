=Install And Usage=

This guide is only for Linux OS and it has only been tested with Ubuntu 12.04 on a 64-bit machine.

==Requirements==

  If your OS is linux 64 bits, then you need to install the 32-bit libraries:

  For Ubuntu:
       sudo apt-get install ia32-libs libc6-i386 libc6-dev-i386 lib32gcc1 
       lib32stdc++6 g++-4.6-multilib lib32bz2-dev  lib32z1-dev

  Also, you might need to add manually the symbolic link:
       ln -s /usr/lib32/libstdc++.so.6 /usr/lib32/libstdc++.so



==Setup==

The distribution comes as a compressed tarball named
ftclp.xx.yy.tar.gz, where xx.yy is a version number. Unpack the
distribution somewhere in your home directory and set the value of the
environment variable FTCLP_INSTALL to the absolute path of the
distribution. For example, if you've unpacked the distribution in the
directory /home/jorge/ftclp.xx.yy, then you shall add the
following commands to your profile:

{{{
export FTCLP_INSTALL=/home/jorge/ftclp.xx.yy
}}}

You might also want to update your PATH variable as follows:

{{{
export PATH=${PATH}:${FTCLP_INSTALL}/bin
}}}

{{{
make install
}}}

This will install any required third-party system.

{{{
make all
}}}

This will compile all the files and will generate the executable file
ftclp.xx.yy in the bin directory.

==Usage==

{{{
ftclp.xx.yy -help

Failure Tabled Constraint Logic Programming by Interpolation
         by G. Gange, J.A. Navas, P. Schachte, H. Sondergaard, and P.J. Stuckey.
         (C)2013 The University of Melbourne.
  Description: CLP interpreter with failure-based tabling.

  Usage: cmmd -goal <G> -f  <input_file> [options] 
         G must be a single CLP term between single quotes (e.g., 'foo(X)') 
         For multiple goals G1,...,Gn wrap them into a predicate 
         wrap(...) :- G1,...,Gn. and call with -goal 'wrap(...)'

  Options: 
    -help               : display this list of options
    -debug              : debug mode
    -dot-output         : display derivation tree in dot format
    -show-answers       : show answers
    -dump-interpolants  : write interpolants to <input_file>.intp
                          enable -pred-pruning option.
    -depth     <n>      : explore up to depth n  (default unlimited)
    -solutions <n>      : compute n solutions    (default all solutions)
    -integer-arithmetic : use integer linear arithmetic. (default reals).
    -clause-pruning     : pruning at the level of clause (default no pruning)
    -pred-pruning       : pruning at the level of predicate (default no pruning)
    -infinite-pruning   : pruning infinite derivations (default no pruning)
                          enable -pred-pruning option.
    -minimize-intp-calls: optimization to minimize the number of interpolation calls
                          (only if interpolants are inductive).
    -unscoped-intp      : generation of not necessarily well scoped interpolants
    -scoped-intp        : generation of well scoped interpolants
    -disjunctive-intp   : build fully disjunctive interpolants
}}}

===Common Usage Configurations===

  # Standard CLP without tabling: run without options
  # Failure-Tabling CLP: run with options -clause-pruning -unscoped-intp
  # Failure-Tabling CLP with special treatment for infinite derivations: run with options -clause-pruning -unscoped-intp -infinite-pruning

To see the answers generated by the CLP program use the option -show-answers. Currently, the format of the answers is a very limited. Current CLP systems dump the state of the solver and projected onto a set of variables of interest. Instead, we simply print the sequence of executed clauses that led to a solution. A clause is denoted by p/n/k where p is the name of the predicate functor, n is the arity of the predicate, and k is the number of the clause. The number of the clauses are assigned based on the order the clauses appear in the program.